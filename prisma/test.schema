// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client"
  previewFeatures = ["relationJoins"]
  output          = "generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model users {
  id                   String                 @id @default(ulid())
  email                String                 @unique
  name                 String
  emailVerified        Boolean
  image                String?
  role                 String?
  banned               Boolean?
  banReason            String?
  banExpires           Int?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  sessions             sessions[]
  accounts             accounts[]
  exerciseSetups       ExerciseSetup[]
  ExerciseLibraryVideo ExerciseLibraryVideo[]
}

model sessions {
  id             String   @id @default(ulid())
  expiresAt      DateTime
  token          String   @unique
  impersonatedBy String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  ipAddress      String?
  userAgent      String?
  userId         String
  user           users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, token])
}

model accounts {
  id                    String    @id @default(ulid())
  accountId             String
  providerId            String
  userId                String
  user                  users     @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
}

model verifications {
  id         String    @id @default(ulid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@index([identifier])
}

// model ExerciseLibrary {
//   id              String           @id @default(ulid())
//   title           String
//   createdAt       DateTime         @default(now())
//   updatedAt       DateTime         @updatedAt
//   exLibBodyParts  ExLibBodyPart[]
//   exLibEquipments ExLibEquipment[]
//   exLibRaks       ExLibRak[]
// }

model BodyPart {
  id              String            @id @default(ulid())
  name            String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  exLibBodyParts  ExLibBodyPart[]
  ExSetupBodyPart ExSetupBodyPart[]
}

model Equipment {
  id                   String                @id @default(ulid())
  name                 String
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  exLibEquipments      ExLibEquipment[]
  demoCenterEquipments DemoCenterEquipment[]
  ExSetupEquipment     ExSetupEquipment[]
}

model Rack {
  id         String       @id @default(ulid())
  name       String
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  exLibRaks  ExLibRak[]
  ExSetupRak ExSetupRak[]
}

model DemoCenter {
  id                   String                @id @default(ulid())
  buildingType         String
  name                 String
  address              String
  contact              String
  cityZip              String
  bio                  String
  image                String
  availability         String?
  weekdays             String[]
  weekends             String[]
  weekdayOpen          String?
  weekdayClose         String?
  weekendOpen          String?
  weekendClose         String?
  isPublic             Boolean               @default(false)
  blocked              Boolean               @default(false)
  blockReason          String?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  demoCenterEquipments DemoCenterEquipment[]
}

model DemoCenterEquipment {
  id           String     @id @default(ulid())
  demoCenterId String
  demoCenter   DemoCenter @relation(fields: [demoCenterId], references: [id], onDelete: Cascade)
  equipmentId  String
  equipment    Equipment  @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  createdAt    DateTime
  updatedAt    DateTime
}

model ExLibBodyPart {
  id          String               @id @default(ulid())
  exLibraryId String
  exLibrary   ExerciseLibraryVideo @relation(fields: [exLibraryId], references: [id], onDelete: Cascade)
  bodyPartId  String
  bodyPart    BodyPart             @relation(fields: [bodyPartId], references: [id], onDelete: Cascade)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
}

model ExLibEquipment {
  id          String               @id @default(ulid())
  exLibraryId String
  exLibrary   ExerciseLibraryVideo @relation(fields: [exLibraryId], references: [id], onDelete: Cascade)
  equipmentId String
  equipment   Equipment            @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
}

model ExLibRak {
  id          String               @id @default(ulid())
  exLibraryId String
  exLibrary   ExerciseLibraryVideo @relation(fields: [exLibraryId], references: [id], onDelete: Cascade)
  rackId      String
  rack        Rack                 @relation(fields: [rackId], references: [id], onDelete: Cascade)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
}

model ExerciseLibraryVideo {
  id             String           @id @default(ulid())
  title          String
  videoUrl       String
  height         String?
  userId         String
  user           users            @relation(fields: [userId], references: [id], onDelete: Cascade)
  isPublic       Boolean          @default(false)
  blocked        Boolean          @default(false)
  blockReason    String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  ExLibBodyPart  ExLibBodyPart[]
  ExLibEquipment ExLibEquipment[]
  ExLibRak       ExLibRak[]

  @@index([userId])
  @@index([isPublic, blocked])
}

model ExSetupBodyPart {
  id         String        @id @default(ulid())
  exSetupId  String
  exSetup    ExerciseSetup @relation(fields: [exSetupId], references: [id], onDelete: Cascade)
  bodyPartId String
  bodyPart   BodyPart      @relation(fields: [bodyPartId], references: [id], onDelete: Cascade)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
}

model ExSetupEquipment {
  id          String        @id @default(ulid())
  exSetupId   String
  exSetup     ExerciseSetup @relation(fields: [exSetupId], references: [id], onDelete: Cascade)
  equipmentId String
  equipment   Equipment     @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model ExSetupRak {
  id        String        @id @default(ulid())
  exSetupId String
  exSetup   ExerciseSetup @relation(fields: [exSetupId], references: [id], onDelete: Cascade)
  rackId    String
  rack      Rack          @relation(fields: [rackId], references: [id], onDelete: Cascade)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
}

model ExerciseSetup {
  id               String             @id @default(ulid())
  title            String
  videoUrl         String
  height           String
  userId           String
  user             users              @relation(fields: [userId], references: [id], onDelete: Cascade)
  isPublic         Boolean            @default(false)
  blocked          Boolean            @default(false)
  blockReason      String?
  // Pump by numbers fields
  isolatorHole     String?
  yellow           String?
  green            String?
  blue             String?
  red              String?
  purple           String?
  orange           String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  ExSetupBodyPart  ExSetupBodyPart[]
  ExSetupEquipment ExSetupEquipment[]
  ExSetupRak       ExSetupRak[]
}



import cloudinary from "@/app/api/lib/cloudinary";
import prisma from "@/lib/prisma";
import {
  exerciseLibrarySchema,
  exerciseLibrarySchemaAdmin,
} from "@/schema/exerciseLibrarySchema";
import { InferType } from "yup";

export const exerciseLibraryService = {
  createExerciseLibraryAdmin: async (
    data: InferType<typeof exerciseLibrarySchemaAdmin>,
  ) => {
    try {
      console.log(data);

      const exerciseLibrary = await prisma.exerciseLibraryVideo.create({
        data: {
          title: data.title,
          videoUrl: data.videoUrl,
          height: data.height?.trim() || null,
          userId: data.userId,
          // Create junction table records for equipment
          ExLibEquipment: {
            create:
              (data.equipment?.filter(Boolean) as string[])?.map(
                (equipmentId) => ({
                  equipmentId: equipmentId,
                }),
              ) || [],
          },
          // Create junction table records for body parts
          ExLibBodyPart: {
            create:
              (data.bodyPart?.filter(Boolean) as string[])?.map(
                (bodyPartId) => ({
                  bodyPartId: bodyPartId,
                }),
              ) || [],
          },
          // Create junction table records for racks
          ExLibRak: {
            create:
              (data.rack?.filter(Boolean) as string[])?.map((rackId) => ({
                rackId: rackId,
              })) || [],
          },
        },
        include: {
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      return exerciseLibrary;
    } catch (error) {
      console.error("Error creating exercise library video:", error);
      throw error;
    }
  },
  // Get all exercise library videos for dashboard (admin)
  getAllExerciseLibraryVideos: async (page = 1, limit = 10, search = "") => {
    try {
      const skip = (page - 1) * limit;

      // Build where clause for search
      const where: any = search
        ? {
            OR: [
              { title: { contains: search, mode: "insensitive" as const } },
              {
                ExLibEquipment: {
                  some: {
                    equipment: {
                      name: { contains: search, mode: "insensitive" as const },
                    },
                  },
                },
              },
              {
                ExLibBodyPart: {
                  some: {
                    bodyPart: {
                      name: { contains: search, mode: "insensitive" as const },
                    },
                  },
                },
              },
              {
                ExLibRak: {
                  some: {
                    rack: {
                      name: { contains: search, mode: "insensitive" as const },
                    },
                  },
                },
              },
            ],
          }
        : {};

      // Get total count
      const total = await prisma.exerciseLibraryVideo.count({ where });

      // Get paginated data with junction tables
      const exercises = await prisma.exerciseLibraryVideo.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          createdAt: "desc",
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      return {
        data: exercises,
        meta: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      console.error("Error fetching all exercise library videos:", error);
      throw new Error("Failed to fetch exercise library videos.");
    }
  },

  // Get single exercise library video by ID
  getExerciseLibraryVideoById: async (id: string) => {
    try {
      const exercise = await prisma.exerciseLibraryVideo.findUnique({
        where: { id },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      if (!exercise) {
        throw new Error("Exercise library video not found");
      }

      return exercise;
    } catch (error) {
      console.error("Error fetching exercise library video:", error);
      throw new Error("Failed to fetch exercise library video.");
    }
  },

  // Update exercise library video
  updateExerciseLibraryVideo: async (
    id: string,
    data: InferType<typeof exerciseLibrarySchemaAdmin>,
  ) => {
    try {
      // First, delete existing junction table records
      await prisma.exLibEquipment.deleteMany({
        where: { exLibraryId: id },
      });
      await prisma.exLibBodyPart.deleteMany({
        where: { exLibraryId: id },
      });
      await prisma.exLibRak.deleteMany({
        where: { exLibraryId: id },
      });

      // Then update the exercise library and create new junction table records
      const exercise = await prisma.exerciseLibraryVideo.update({
        where: { id },
        data: {
          title: data.title,
          videoUrl: data.videoUrl,
          height: data.height && data.height.trim() !== "" ? data.height : null,
          updatedAt: new Date(),
          // Create new junction table records for equipment
          ExLibEquipment: {
            create:
              (data.equipment?.filter(Boolean) as string[])?.map(
                (equipmentId) => ({
                  equipmentId: equipmentId,
                }),
              ) || [],
          },
          // Create new junction table records for body parts
          ExLibBodyPart: {
            create:
              (data.bodyPart?.filter(Boolean) as string[])?.map(
                (bodyPartId) => ({
                  bodyPartId: bodyPartId,
                }),
              ) || [],
          },
          // Create new junction table records for racks
          ExLibRak: {
            create:
              (data.rack?.filter(Boolean) as string[])?.map((rackId) => ({
                rackId: rackId,
              })) || [],
          },
        },
        include: {
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      return exercise;
    } catch (error) {
      console.error("Error updating exercise library video:", error);
      throw new Error("Failed to update exercise library video.");
    }
  },

  // Delete exercise library video
  deleteExerciseLibraryVideo: async (id: string) => {
    try {
      const exercise = await prisma.exerciseLibraryVideo.delete({
        where: { id },
      });

      return exercise;
    } catch (error) {
      console.error("Error deleting exercise library video:", error);
      throw new Error("Failed to delete exercise library video.");
    }
  },

  // Block exercise library video
  blockExerciseLibraryVideo: async (id: string, blockReason: string) => {
    try {
      const exercise = await prisma.exerciseLibraryVideo.update({
        where: { id },
        data: {
          blocked: true,
          blockReason,
          updatedAt: new Date(),
        },
      });

      return exercise;
    } catch (error) {
      console.error("Error blocking exercise library video:", error);
      throw new Error("Failed to block exercise library video.");
    }
  },

  // Unblock exercise library video
  unblockExerciseLibraryVideo: async (id: string) => {
    try {
      const exercise = await prisma.exerciseLibraryVideo.update({
        where: { id },
        data: {
          blocked: false,
          blockReason: null,
          updatedAt: new Date(),
        },
      });

      return exercise;
    } catch (error) {
      console.error("Error unblocking exercise library video:", error);
      throw new Error("Failed to unblock exercise library video.");
    }
  },

  // Update exercise library video status (publish/unpublish)
  updateExerciseLibraryVideoStatus: async (
    id: string,
    data: { isPublic?: boolean; blocked?: boolean; blockReason?: string },
  ) => {
    try {
      const updateData: {
        updatedAt: Date;
        isPublic?: boolean;
        blocked?: boolean;
        blockReason?: string;
      } = {
        updatedAt: new Date(),
      };

      if (data.isPublic !== undefined) {
        updateData.isPublic = data.isPublic;
      }

      if (data.blocked !== undefined) {
        updateData.blocked = data.blocked;
      }

      if (data.blockReason !== undefined) {
        updateData.blockReason = data.blockReason;
      }

      const exercise = await prisma.exerciseLibraryVideo.update({
        where: { id },
        data: updateData,
      });

      return exercise;
    } catch (error) {
      console.error("Error updating exercise library video status:", error);
      throw new Error("Failed to update exercise library video status.");
    }
  },

  createExerciseLibrary: async (
    data: InferType<typeof exerciseLibrarySchema> & { video: File },
  ) => {
    try {
      // Check Cloudinary environment variables
      if (
        !process.env.CLOUDINARY_CLOUD_NAME ||
        !process.env.CLOUDINARY_API_KEY ||
        !process.env.CLOUDINARY_API_SECRET
      ) {
        console.error("Missing Cloudinary environment variables");
        throw new Error("Cloudinary configuration is missing");
      }

      console.log("Starting video upload process...");
      console.log("Video file info:", {
        name: data.video.name,
        size: data.video.size,
        type: data.video.type,
      });

      // Convert File to base64 Data URI
      const buffer = await data.video.arrayBuffer();
      const base64 = Buffer.from(buffer).toString("base64");
      const dataURI = `data:${data.video.type};base64,${base64}`;

      console.log("Uploading to Cloudinary...");
      const uploadResult = await cloudinary.uploader.upload(dataURI, {
        resource_type: "video",
        folder: "exercise-library",
      });

      console.log("Cloudinary upload successful:", uploadResult.secure_url);

      // Save to Prisma DB
      const created = await prisma.exerciseLibraryVideo.create({
        data: {
          title: data.title,
          height: data.height,
          videoUrl: uploadResult.secure_url,
          userId: data.userId,
          // Create junction table records for equipment
          ExLibEquipment: {
            create:
              (data.equipment?.filter(Boolean) as string[])?.map(
                (equipmentId) => ({
                  equipmentId: equipmentId,
                }),
              ) || [],
          },
          // Create junction table records for body parts
          ExLibBodyPart: {
            create:
              (data.bodyPart?.filter(Boolean) as string[])?.map(
                (bodyPartId) => ({
                  bodyPartId: bodyPartId,
                }),
              ) || [],
          },
          // Create junction table records for racks
          ExLibRak: {
            create:
              (data.rack?.filter(Boolean) as string[])?.map((rackId) => ({
                rackId: rackId,
              })) || [],
          },
        },
        include: {
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      console.log("Database save successful:", created.id);

      // 🔥 Trigger Zapier webhook (optional via env flag)
      if (created?.id && process.env.ZAPIER_WEBHOOK_URL) {
        console.log("Sending data to Zapier...,created", created);
        try {
          const zapierResponse = await fetch(process.env.ZAPIER_WEBHOOK_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              // Basic exercise info
              title: created.title,
              description: `Exercise using ${created.ExLibEquipment[0]?.equipment?.name || "Unknown Equipment"} for ${created.ExLibBodyPart[0]?.bodyPart?.name || "Unknown Body Part"}`,
              videoUrl: created.videoUrl,
              id: created.id,

              // Additional metadata for Zapier
              equipment: created.ExLibEquipment.map((eq) => eq.equipment.name),
              bodyPart: created.ExLibBodyPart.map((bp) => bp.bodyPart.name),
              height: created.height,
              rack: created.ExLibRak.map((r) => r.rack.name),
              userId: created.userId,
              createdAt: created.createdAt,
              updatedAt: created.updatedAt,

              // Zapier-specific fields
              event_type: "exercise_library_created",
              source: "bulletproof_fitness_app",
            }),
            // Add timeout to prevent hanging
            signal: AbortSignal.timeout(10000), // 10 second timeout
          });

          if (!zapierResponse.ok) {
            console.warn(
              `Zapier webhook failed with status: ${zapierResponse.status}`,
            );
          } else {
            console.log("Zapier webhook sent successfully.");
          }
        } catch (zapierError) {
          console.error("Zapier webhook error:", zapierError);
          // Don't fail the main operation if Zapier fails
        }
      } else {
        console.warn("Zapier webhook URL not set. Skipping...");
      }

      return created;
    } catch (error) {
      console.error("Upload or DB save error:", error);
      throw new Error("Failed to upload and save exercise library data.");
    }
  },

  // Get exercise library data for a user (public access)
  getExerciseLibrary: async () => {
    try {
      const exercises = await prisma.exerciseLibraryVideo.findMany({});

      return exercises;
    } catch (error) {
      console.error("Error fetching exercise library:", error);
      throw new Error("Failed to fetch exercise library data.");
    }
  },

  // Get exercise library with comprehensive filters and pagination
  getExerciseLibraryWithFilters: async (params: {
    page?: number;
    limit?: number;
    search?: string;
    bodyPartIds?: string[];
    equipmentIds?: string[];
    rackIds?: string[];
    username?: string;
    minHeight?: number;
    maxHeight?: number;
    minRating?: number;
    sortBy?: "title" | "createdAt" | "views" | "likes";
    sortOrder?: "asc" | "desc";
  }) => {
    try {
      const {
        page = 1,
        limit = 12,
        search = "",
        bodyPartIds = [],
        equipmentIds = [],
        rackIds = [],
        username = "",
        minHeight = 0,
        maxHeight = 85,
        minRating = 0,
        sortBy = "createdAt",
        sortOrder = "desc",
      } = params;

      const skip = (page - 1) * limit;

      // Build comprehensive where clause
      const where: any = {
        isPublic: true,
        blocked: false,
        AND: [],
      };

      // Search filter
      if (search) {
        where.AND.push({
          OR: [
            { title: { contains: search, mode: "insensitive" as const } },
            {
              ExLibEquipment: {
                some: {
                  equipment: {
                    name: { contains: search, mode: "insensitive" as const },
                  },
                },
              },
            },
            {
              ExLibBodyPart: {
                some: {
                  bodyPart: {
                    name: { contains: search, mode: "insensitive" as const },
                  },
                },
              },
            },
            {
              ExLibRak: {
                some: {
                  rack: {
                    name: { contains: search, mode: "insensitive" as const },
                  },
                },
              },
            },
          ],
        });
      }

      // Body part filter
      if (bodyPartIds.length > 0) {
        where.AND.push({
          ExLibBodyPart: {
            some: {
              bodyPartId: { in: bodyPartIds },
            },
          },
        });
      }

      // Equipment filter
      if (equipmentIds.length > 0) {
        where.AND.push({
          ExLibEquipment: {
            some: {
              equipmentId: { in: equipmentIds },
            },
          },
        });
      }

      // Rack filter
      if (rackIds.length > 0) {
        where.AND.push({
          ExLibRak: {
            some: {
              rackId: { in: rackIds },
            },
          },
        });
      }

      // Username filter
      if (username) {
        where.AND.push({
          user: {
            name: { contains: username, mode: "insensitive" as const },
          },
        });
      }

      // Height filter - only apply if we have height constraints
      if (minHeight > 0 || maxHeight < 85) {
        where.AND.push({
          height: {
            not: null,
          },
        });
      }

      // Get total count
      const total = await prisma.exerciseLibraryVideo.count({
        where,
      });

      // Get paginated data with user info and junction tables
      const exercises = await prisma.exerciseLibraryVideo.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          [sortBy]: sortOrder,
        },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          ExLibEquipment: {
            include: {
              equipment: true,
            },
          },
          ExLibBodyPart: {
            include: {
              bodyPart: true,
            },
          },
          ExLibRak: {
            include: {
              rack: true,
            },
          },
        },
      });

      // Transform data to include additional fields
      const transformedExercises = exercises
        .map((exercise) => {
          // Parse height to inches
          let heightInInches: number | null = null;
          if (exercise.height && exercise.height.trim() !== "") {
            const heightMatch = exercise.height.match(/(\d+)'(\d+)"/);
            if (heightMatch) {
              const feet = parseInt(heightMatch[1]);
              const inches = parseInt(heightMatch[2]);
              heightInInches = feet * 12 + inches;
            } else {
              heightInInches = parseInt(exercise.height || "0", 10);
            }
          }

          // Apply height filter after parsing
          if ((minHeight > 0 || maxHeight < 85) && heightInInches !== null) {
            if (heightInInches < minHeight || heightInInches > maxHeight) {
              return null;
            }
          }

          // Apply rating filter (using mock rating for now)
          if (minRating > 0) {
            const mockRating = Math.random() * 5;
            if (mockRating < minRating) {
              return null;
            }
          }

          return {
            id: exercise.id,
            title: exercise.title,
            videoUrl: exercise.videoUrl,
            equipment: {
              id: exercise.ExLibEquipment[0]?.equipment?.id || "default",
              name:
                exercise.ExLibEquipment[0]?.equipment?.name ||
                "Unknown Equipment",
            },
            bodyPart: {
              id: exercise.ExLibBodyPart[0]?.bodyPart?.id || "default",
              name:
                exercise.ExLibBodyPart[0]?.bodyPart?.name ||
                "Unknown Body Part",
            },
            rack: exercise.ExLibRak[0]
              ? {
                  id: exercise.ExLibRak[0].rack.id,
                  name: exercise.ExLibRak[0].rack.name,
                }
              : undefined,
            height: heightInInches || 0,
            userId: exercise.userId,
            user: exercise.user,
            // Mock data for demo (replace with real data when available)
            views: Math.floor(Math.random() * 1000) + 100,
            likes: Math.floor(Math.random() * 50),
            comments: Math.floor(Math.random() * 10),
            saves: Math.floor(Math.random() * 20),
            rating: Math.floor(Math.random() * 5) + 1,
            label: ["Yellow", "Green", "Blue", "Red"][
              Math.floor(Math.random() * 4)
            ],
            isPublic: exercise.isPublic,
            blocked: exercise.blocked,
            blockReason: exercise.blockReason,
            createdAt: exercise.createdAt.toISOString(),
            updatedAt: exercise.updatedAt.toISOString(),
          };
        })
        .filter(Boolean);

      return {
        data: transformedExercises,
        meta: {
          total,
          page,
          limit,
          totalPages: Math.ceil(total / limit),
          hasNextPage: page < Math.ceil(total / limit),
          hasPrevPage: page > 1,
        },
      };
    } catch (error) {
      console.error("Error fetching exercise library with filters:", error);
      throw new Error("Failed to fetch exercise library data with filters.");
    }
  },
};
